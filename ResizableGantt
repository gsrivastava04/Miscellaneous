import React, { useState, useMemo } from 'react';

// Icon components
const ChevronDown = ({ style, ...props }) => (
  <svg style={style} {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
  </svg>
);

const ChevronRight = ({ style, ...props }) => (
  <svg style={style} {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
  </svg>
);

const Folder = ({ style, ...props }) => (
  <svg style={style} {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
  </svg>
);

const FolderOpen = ({ style, ...props }) => (
  <svg style={style} {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z" />
  </svg>
);

const CheckCircle = ({ style, ...props }) => (
  <svg style={style} {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>
);

const XCircle = ({ style, ...props }) => (
  <svg style={style} {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>
);

const Play = ({ style, ...props }) => (
  <svg style={style} {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1.586a1 1 0 01.707.293l2.414 2.414a1 1 0 00.707.293H15M13 16h3a2 2 0 002-2V9a2 2 0 00-2-2h-3" />
  </svg>
);

const Pause = ({ style, ...props }) => (
  <svg style={style} {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
  </svg>
);

const X = ({ style, ...props }) => (
  <svg style={style} {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
  </svg>
);

const JobGanttChart = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [collapsedTasks, setCollapsedTasks] = useState(new Set());
  const [hoveredJob, setHoveredJob] = useState(null);
  const [tooltipPosition, setTooltipPosition] = useState({ x: 0, y: 0 });
  const [columnWidth, setColumnWidth] = useState(400);
  const [isResizing, setIsResizing] = useState(false);
  
  // Parse date strings with timezone handling
  const parseDate = (dateString) => {
    if (!dateString) return null;
    
    if (typeof dateString === 'string') {
      if (dateString.includes('+') || dateString.includes('-')) {
        let cleanDate = dateString.replace(/(\d{4})\/(\d{2})\/(\d{2})/, '$1-$2-$3');
        return new Date(cleanDate);
      }
      
      let cleanDate = dateString.replace(/\.\d{3}/, '');
      cleanDate = cleanDate.replace(/(\d{4})\/(\d{2})\/(\d{2})/, '$1-$2-$3');
      return new Date(cleanDate);
    }
    
    return new Date(dateString);
  };

  // Sample job data representing a data processing pipeline
  const jobData = {
    "jobs": [
      {"id": "JOB_001", "name": "Daily_Data_Extract", "startdate": "2025/05/28 06:00:00.000 +0000", "enddate": "2025/05/28 16:15:00.000 +0000", "status": "SUCCESS", "progress": 100, "dependency": [], "parent": null},
      
      {"id": "NEWJ_001", "name": "Data_Processing_Pipeline", "startdate": null, "enddate": null, "status": "RUNNING", "progress": 0, "dependency": [], "parent": null},
      
      {"id": "NEWJ_001_VALIDATION", "name": "Data_Validation_Phase", "startdate": "2025/05/28 09:00:00.000 +0000", "enddate": "2025/05/28 12:00:00.000 +0000", "status": "SUCCESS", "progress": 0, "dependency": [], "parent": "JOB_001"},
      {"id": "NEWJ_001_TRANSFORM", "name": "Data_Transformation_Phase", "startdate": "2025/05/28 08:00:00.000 +0000", "enddate": "2025/05/28 10:30:00.000 +0000", "status": "RUNNING", "progress": 0, "dependency": [], "parent": "JOB_001"},
      {"id": "NEWJ_001_OUTPUT", "name": "Output_Generation_Phase", "startdate": "2025/05/28 09:10:00.000 +0000", "enddate": "2025/05/28 09:50:00.000 +0000", "status": "WAITING", "progress": 0, "dependency": [], "parent": "JOB_001"},
      
      {"id": "JOB_002", "name": "Customer_Data_Validation", "startdate": "2025/05/28 09:10:00.000 +0000", "enddate": "2025/05/28 09:25:00.000 +0000", "status": "SUCCESS", "progress": 100, "dependency": ["JOB_001"], "parent": "NEWJ_001_VALIDATION"},
      {"id": "JOB_003", "name": "Financial_Data_Validation", "startdate": "2025/05/28 10:15:00.000 +0000", "enddate": "2025/05/28 11:30:00.000 +0000", "status": "SUCCESS", "progress": 100, "dependency": ["JOB_001"], "parent": "NEWJ_001_VALIDATION"},
      
      {"id": "NEWJ_CUSTOMER_SUBTASKS", "name": "Customer_Validation_Subtasks", "startdate": null, "enddate": null, "status": "SUCCESS", "progress": 0, "dependency": [], "parent": "JOB_002"},
      {"id": "JOB_002_A", "name": "Email_Format_Check", "startdate": "2025/05/28 06:15:00.000 +0000", "enddate": "2025/05/28 06:18:00.000 +0000", "status": "SUCCESS", "progress": 100, "dependency": [], "parent": "NEWJ_CUSTOMER_SUBTASKS"},
      {"id": "JOB_002_B", "name": "Phone_Number_Validation", "startdate": "2025/05/28 06:18:00.000 +0000", "enddate": "2025/05/28 06:22:00.000 +0000", "status": "SUCCESS", "progress": 100, "dependency": ["JOB_002_A"], "parent": "NEWJ_CUSTOMER_SUBTASKS"},
      {"id": "JOB_002_C", "name": "Address_Standardization", "startdate": "2025/05/28 06:22:00.000 +0000", "enddate": "2025/05/28 06:25:00.000 +0000", "status": "SUCCESS", "progress": 100, "dependency": ["JOB_002_B"], "parent": "NEWJ_CUSTOMER_SUBTASKS"},
      
      {"id": "JOB_004", "name": "Data_Transformation", "startdate": "2025/05/28 06:30:00.000 +0000", "enddate": "2025/05/28 07:00:00.000 +0000", "status": "RUNNING", "progress": 65, "dependency": ["JOB_002", "JOB_003"], "parent": "NEWJ_001_TRANSFORM"},
      {"id": "JOB_004_CLEAN", "name": "Data_Cleaning", "startdate": "2025/05/28 06:30:00.000 +0000", "enddate": "2025/05/28 06:45:00.000 +0000", "status": "SUCCESS", "progress": 100, "dependency": ["JOB_002", "JOB_003"], "parent": "NEWJ_001_TRANSFORM"},
      
      {"id": "JOB_005", "name": "Report_Generation", "startdate": null, "enddate": null, "status": "WAITING", "progress": 0, "dependency": ["JOB_004"], "parent": "NEWJ_001_OUTPUT"},
      {"id": "JOB_006", "name": "Email_Notification", "startdate": null, "enddate": null, "status": "WAITING", "progress": 0, "dependency": ["JOB_005"], "parent": "NEWJ_001_OUTPUT"},
      
      {"id": "JOB_007", "name": "Database_Backup", "startdate": "2025/05/28 02:00:00.000 +0000", "enddate": "2025/05/28 12:00:00.000 +0000", "status": "SUCCESS", "progress": 100, "dependency": [], "parent": null},
      {"id": "JOB_008", "name": "Log_Cleanup", "startdate": "2025/05/28 03:00:00.000 +0000", "enddate": "2025/05/28 03:05:00.000 +0000", "status": "SUCCESS", "progress": 100, "dependency": ["JOB_007"], "parent": null},
      
      {"id": "NEWJ_002", "name": "System_Monitoring_Suite", "startdate": null, "enddate": null, "status": "FAILED", "progress": 0, "dependency": [], "parent": null},
      {"id": "JOB_009", "name": "System_Health_Check", "startdate": "2025/05/28 04:00:00.000 +0000", "enddate": null, "status": "FAILED", "progress": 80, "dependency": [], "parent": "NEWJ_002"},
      {"id": "JOB_010", "name": "Alert_Generation", "startdate": null, "enddate": null, "status": "WAITING", "progress": 0, "dependency": ["JOB_009"], "parent": "NEWJ_002"},
      
      {"id": "JOB_016", "name": "Very_Long_Job_Name_That_Demonstrates_Layout", "startdate": "2025/05/28 08:00:00.000 +0000", "enddate": "2025/05/28 08:30:00.000 +0000", "status": "RUNNING", "progress": 45, "dependency": ["JOB_004"], "parent": null}
    ]
  };

  // Build hierarchical structure from flat job list
  const buildHierarchy = (jobs) => {
    const jobMap = new Map();
    const rootJobs = [];
    
    // Create job objects with processed data
    jobs.forEach(job => {
      const processedJob = {
        ...job,
        name: job.name.replace(/_/g, ' '),
        startdate: parseDate(job.startdate),
        enddate: parseDate(job.enddate),
        children: [],
        level: 0
      };
      
      jobMap.set(job.id, processedJob);
    });
    
    // Build parent-child relationships
    jobMap.forEach(job => {
      if (job.parent) {
        const parent = jobMap.get(job.parent);
        if (parent) {
          parent.children.push(job);
          job.level = parent.level + 1;
        }
      } else {
        rootJobs.push(job);
      }
    });
    
    // Sort children by start date
    const sortChildrenByStartDate = (jobList) => {
      jobList.forEach(job => {
        if (job.children.length > 0) {
          job.children.sort((a, b) => {
            if (!a.startdate && !b.startdate) return 0;
            if (!a.startdate) return 1;
            if (!b.startdate) return -1;
            return a.startdate.getTime() - b.startdate.getTime();
          });
          sortChildrenByStartDate(job.children);
        }
      });
    };
    
    // Calculate container properties for parent jobs
    const calculateContainerProperties = (job) => {
      if (job.children.length === 0) return;
      
      job.children.forEach(child => {
        if (child.children.length > 0) {
          calculateContainerProperties(child);
        }
      });
      
      const childDates = job.children
        .filter(child => child.startdate)
        .map(child => ({ start: child.startdate, end: child.enddate }));
      
      if (childDates.length > 0) {
        job.startdate = new Date(Math.min(...childDates.map(d => d.start.getTime())));
        const endDates = childDates.filter(d => d.end).map(d => d.end.getTime());
        if (endDates.length > 0) {
          job.enddate = new Date(Math.max(...endDates));
        }
      }
      
      // Calculate average progress
      if (job.children.length > 0) {
        const totalProgress = job.children.reduce((sum, child) => sum + child.progress, 0);
        job.progress = Math.round(totalProgress / job.children.length);
      }
      
      // Determine status based on children
      if (job.children.length > 0) {
        if (job.children.every(child => child.status === 'SUCCESS')) {
          job.status = 'SUCCESS';
        } else if (job.children.some(child => child.status === 'FAILED')) {
          job.status = 'FAILED';
        } else if (job.children.some(child => child.status === 'RUNNING')) {
          job.status = 'RUNNING';
        } else if (job.children.some(child => child.status === 'WAITING')) {
          job.status = 'WAITING';
        }
      }
    };
    
    const calculateAllContainerProperties = (jobList) => {
      jobList.forEach(job => {
        calculateContainerProperties(job);
        if (job.children.length > 0) {
          calculateAllContainerProperties(job.children);
        }
      });
    };
    
    calculateAllContainerProperties(rootJobs);
    sortChildrenByStartDate(rootJobs);
    
    return rootJobs.sort((a, b) => {
      if (!a.startdate && !b.startdate) return 0;
      if (!a.startdate) return 1;
      if (!b.startdate) return -1;
      return a.startdate.getTime() - b.startdate.getTime();
    });
  };

  const [jobs] = useState(buildHierarchy(jobData.jobs));

  // Generate 30-hour timeline
  const timelineRange = useMemo(() => {
    const dates = [];
    let earliestDate = null;
    
    const findEarliestDate = (jobList) => {
      jobList.forEach(job => {
        if (job.startdate) {
          const startDate = parseDate(job.startdate);
          if (startDate && (!earliestDate || startDate < earliestDate)) {
            earliestDate = startDate;
          }
        }
        if (job.children && job.children.length > 0) {
          findEarliestDate(job.children);
        }
      });
    };
    
    findEarliestDate(jobData.jobs.map(job => ({
      ...job,
      startdate: job.startdate
    })));
    
    if (!earliestDate) {
      earliestDate = parseDate("2025/05/28 02:00:00.000 +0000");
    }
    
    const timelineStart = new Date(earliestDate.getTime() - (60 * 60 * 1000));
    
    for (let hour = 0; hour < 30; hour++) {
      const time = new Date(timelineStart.getTime() + (hour * 60 * 60 * 1000));
      dates.push(time);
    }
    
    return dates;
  }, []);

  // Status color mapping
  const getStatusColor = (status) => {
    switch (status) {
      case 'SUCCESS': return '#10B981';
      case 'RUNNING': return '#F59E0B';
      case 'FAILED': return '#EF4444';
      case 'WAITING': return '#6B7280';
      default: return '#6B7280';
    }
  };

  // Status icon mapping
  const getStatusIcon = (status) => {
    switch (status) {
      case 'SUCCESS': return CheckCircle;
      case 'RUNNING': return Play;
      case 'FAILED': return XCircle;
      case 'WAITING': return Pause;
      default: return CheckCircle;
    }
  };

  // Flatten hierarchical jobs for rendering
  const flattenJobs = (jobs, level = 0) => {
    let result = [];
    
    for (const job of jobs) {
      result.push({ ...job, level });
      
      if (job.children && job.children.length > 0 && !collapsedTasks.has(job.id)) {
        result = result.concat(flattenJobs(job.children, level + 1));
      }
    }
    
    return result;
  };

  const flatJobs = useMemo(() => flattenJobs(jobs), [jobs, collapsedTasks]);

  // Toggle expand/collapse for parent jobs
  const toggleJobCollapse = (jobId) => {
    const newCollapsed = new Set(collapsedTasks);
    if (newCollapsed.has(jobId)) {
      newCollapsed.delete(jobId);
    } else {
      newCollapsed.add(jobId);
    }
    setCollapsedTasks(newCollapsed);
  };

  // Calculate position and width for Gantt bars
  const getJobBarStyle = (job) => {
    if (!job.startdate || timelineRange.length === 0) {
      return { left: '1%', width: '2%' };
    }
    
    const timelineStart = timelineRange[0];
    const timelineEnd = timelineRange[timelineRange.length - 1];
    const timelineDurationMs = timelineEnd.getTime() - timelineStart.getTime();
    
    const jobStartTime = new Date(job.startdate);
    const jobEndTime = job.enddate ? new Date(job.enddate) : new Date(jobStartTime.getTime() + 15 * 60 * 1000);
    
    const jobStartOffset = jobStartTime.getTime() - timelineStart.getTime();
    const jobDuration = jobEndTime.getTime() - jobStartTime.getTime();
    
    const left = Math.max(0, (jobStartOffset / timelineDurationMs) * 100);
    const width = Math.max(0.5, (jobDuration / timelineDurationMs) * 100);
    
    return { 
      left: `${left}%`, 
      width: `${width}%` 
    };
  };

  // Format time for display
  const formatTime = (date) => {
    if (!date) return 'Not scheduled';
    
    const dateObj = date instanceof Date ? date : parseDate(date);
    if (!dateObj || isNaN(dateObj.getTime())) return 'Invalid date';
    
    return dateObj.toLocaleTimeString('en-US', { 
      hour: '2-digit', 
      minute: '2-digit',
      hour12: false,
      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
    });
  };

  const formatDateTime = (date) => {
    if (!date) return 'Not scheduled';
    
    const dateObj = date instanceof Date ? date : parseDate(date);
    if (!dateObj || isNaN(dateObj.getTime())) return 'Invalid date';
    
    return dateObj.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
    }) + ' ' + formatTime(dateObj);
  };

  const formatDuration = (startDate, endDate) => {
    if (!startDate || !endDate) return 'Unknown';
    
    const startObj = startDate instanceof Date ? startDate : parseDate(startDate);
    const endObj = endDate instanceof Date ? endDate : parseDate(endDate);
    
    if (!startObj || !endObj || isNaN(startObj.getTime()) || isNaN(endObj.getTime())) {
      return 'Unknown';
    }
    
    const diffMs = endObj.getTime() - startObj.getTime();
    const diffMinutes = Math.round(diffMs / (1000 * 60));
    
    if (diffMinutes < 60) {
      return `${diffMinutes} min`;
    } else {
      const hours = Math.floor(diffMinutes / 60);
      const minutes = diffMinutes % 60;
      return `${hours}h ${minutes}m`;
    }
  };

  const hasChildren = (job) => job.children && job.children.length > 0;

  const getJobIcon = (job) => {
    if (hasChildren(job)) {
      return collapsedTasks.has(job.id) ? Folder : FolderOpen;
    }
    return getStatusIcon(job.status);
  };

  const handleJobBarHover = (job, event) => {
    setHoveredJob(job);
    setTooltipPosition({
      x: event.clientX,
      y: event.clientY
    });
  };

  const handleJobBarLeave = () => {
    setHoveredJob(null);
  };

  // Handle column resizing
  const handleMouseDown = (e) => {
    e.preventDefault();
    setIsResizing(true);
    
    const startX = e.clientX;
    const startWidth = columnWidth;
    
    const handleMouseMove = (e) => {
      const deltaX = e.clientX - startX;
      const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
      setColumnWidth(newWidth);
    };
    
    const handleMouseUp = () => {
      setIsResizing(false);
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  };

  // CSS styles object
  const styles = {
    container: {
      padding: '16px'
    },
    openButton: {
      padding: '12px 24px',
      backgroundColor: '#2563eb',
      color: 'white',
      border: 'none',
      borderRadius: '8px',
      fontWeight: '500',
      cursor: 'pointer',
      transition: 'background-color 0.2s'
    },
    backdrop: {
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      zIndex: 40
    },
    modal: {
      position: 'fixed',
      top: '16px',
      left: '16px',
      right: '16px',
      bottom: '16px',
      backgroundColor: 'white',
      borderRadius: '8px',
      boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.25)',
      zIndex: 50,
      display: 'flex',
      flexDirection: 'column'
    },
    header: {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'space-between',
      padding: '12px',
      borderBottom: '1px solid #e5e7eb',
      flexShrink: 0
    },
    headerTitle: {
      fontSize: '18px',
      fontWeight: 'bold',
      color: '#111827'
    },
    closeButton: {
      padding: '4px',
      borderRadius: '4px',
      border: 'none',
      backgroundColor: 'transparent',
      cursor: 'pointer',
      transition: 'background-color 0.2s'
    },
    mainContent: {
      flex: 1,
      overflow: 'hidden',
      display: 'flex',
      flexDirection: 'column'
    },
    chartContainer: {
      flex: 1,
      border: '1px solid #e5e7eb',
      margin: '24px',
      marginTop: '24px',
      borderRadius: '8px',
      overflow: 'hidden',
      display: 'flex',
      flexDirection: 'column'
    },
    timelineHeader: {
      backgroundColor: '#f9fafb',
      borderBottom: '1px solid #e5e7eb',
      flexShrink: 0,
      overflowX: 'hidden'
    },
    timelineHeaderContent: {
      display: 'flex'
    },
    jobNameColumn: {
      padding: '12px',
      fontWeight: '600',
      color: '#374151',
      borderRight: '1px solid #e5e7eb',
      overflow: 'hidden',
      display: 'flex',
      alignItems: 'center',
      flexShrink: 0,
      position: 'relative'
    },
    jobNameText: {
      whiteSpace: 'nowrap',
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      width: '100%'
    },
    resizeHandle: {
      position: 'absolute',
      right: 0,
      top: 0,
      height: '100%',
      width: '4px',
      cursor: 'col-resize',
      transition: 'background-color 0.2s',
      marginRight: '-2px'
    },
    resizeHandleInner: {
      position: 'absolute',
      right: 0,
      top: '50%',
      transform: 'translateY(-50%)',
      width: '4px',
      height: '32px',
      backgroundColor: '#9ca3af',
      opacity: 0.5,
      transition: 'opacity 0.2s'
    },
    timelineGrid: {
      flexShrink: 0,
      display: 'flex',
      width: '100%'
    },
    timeCell: {
      padding: '6px',
      fontSize: '12px',
      textAlign: 'center',
      borderRight: '1px solid #e5e7eb',
      color: '#6b7280',
      width: '60px',
      flexShrink: 0,
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center'
    },
    timeCellTime: {
      fontWeight: '500'
    },
    timeCellDate: {
      fontSize: '10px',
      color: '#9ca3af',
      marginTop: '2px'
    },
    jobRowsContainer: {
      flex: 1,
      overflow: 'auto'
    },
    jobRow: {
      display: 'flex',
      borderBottom: '1px solid #e5e7eb',
      transition: 'background-color 0.2s'
    },
    jobRowHover: {
      backgroundColor: '#f9fafb'
    },
    jobNameCell: {
      padding: '12px',
      borderRight: '1px solid #e5e7eb',
      flexShrink: 0,
      overflow: 'hidden',
      position: 'relative'
    },
    jobNameContent: {
      display: 'flex',
      alignItems: 'center',
      width: '100%'
    },
    expandButton: {
      marginRight: '6px',
      padding: '2px',
      borderRadius: '2px',
      border: 'none',
      backgroundColor: 'transparent',
      cursor: 'pointer',
      display: 'flex',
      alignItems: 'center',
      transition: 'background-color 0.2s'
    },
    expandButtonHover: {
      backgroundColor: '#e5e7eb'
    },
    jobIcon: {
      width: '14px',
      height: '14px',
      marginRight: '6px',
      flexShrink: 0
    },
    jobName: {
      whiteSpace: 'nowrap',
      cursor: 'pointer',
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      flex: 1,
      minWidth: 0
    },
    jobNameLevel0: {
      fontWeight: '600',
      color: '#111827',
      fontSize: '14px'
    },
    jobNameParent: {
      fontWeight: '500',
      color: '#111827',
      fontSize: '12px'
    },
    jobNameChild: {
      fontWeight: 'normal',
      color: '#374151',
      fontSize: '12px'
    },
    timelineCell: {
      flexShrink: 0,
      position: 'relative',
      height: '52px',
      padding: '8px'
    },
    timelineBar: {
      position: 'relative',
      height: '100%',
      width: '100%'
    },
    jobBar: {
      position: 'absolute',
      top: '50%',
      transform: 'translateY(-50%)',
      borderRadius: '6px',
      boxShadow: '0 1px 3px 0 rgba(0, 0, 0, 0.1)',
      display: 'flex',
      alignItems: 'center',
      cursor: 'pointer'
    },
    jobBarProgress: {
      height: '100%',
      borderRadius: '6px',
      backgroundColor: 'rgba(255, 255, 255, 0.3)'
    },
    jobBarText: {
      fontWeight: '500',
      color: 'white',
      padding: '0 6px',
      pointerEvents: 'none',
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      width: '100%'
    },
    footer: {
      padding: '24px',
      borderTop: '1px solid #e5e7eb',
      flexShrink: 0
    },
    footerStats: {
      display: 'flex',
      justifyContent: 'center',
      gap: '32px',
      marginBottom: '16px',
      fontSize: '14px',
      color: '#6b7280'
    },
    legend: {
      display: 'flex',
      flexWrap: 'wrap',
      gap: '24px',
      fontSize: '14px',
      justifyContent: 'center'
    },
    legendItem: {
      display: 'flex',
      alignItems: 'center'
    },
    legendIcon: {
      width: '16px',
      height: '16px',
      marginRight: '8px'
    },
    legendText: {
      color: '#6b7280'
    },
    tooltip: {
      position: 'fixed',
      zIndex: 60,
      backgroundColor: '#374151',
      color: 'white',
      padding: '16px',
      borderRadius: '8px',
      boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.25)',
      maxWidth: '320px',
      pointerEvents: 'none'
    },
    tooltipTitle: {
      fontWeight: '600',
      fontSize: '16px',
      marginBottom: '8px'
    },
    tooltipContent: {
      display: 'flex',
      flexDirection: 'column',
      gap: '6px',
      fontSize: '12px'
    },
    tooltipRow: {
      display: 'flex',
      justifyContent: 'space-between'
    },
    tooltipLabel: {
      color: '#d1d5db'
    },
    tooltipValue: {
      fontWeight: '500'
    },
    tooltipDependencies: {
      borderTop: '1px solid #6b7280',
      paddingTop: '8px',
      marginTop: '8px'
    },
    tooltipDependencyTag: {
      fontSize: '10px',
      backgroundColor: '#4b5563',
      padding: '2px 6px',
      borderRadius: '4px',
      display: 'inline-block',
      marginRight: '4px',
      marginBottom: '4px'
    },
    tooltipArrow: {
      position: 'absolute',
      top: '100%',
      left: '16px',
      width: 0,
      height: 0,
      borderLeft: '8px solid transparent',
      borderRight: '8px solid transparent',
      borderTop: '8px solid #374151'
    }
  };

  // Main render - show button if closed
  if (!isOpen) {
    return (
      <div style={styles.container}>
        <button
          onClick={() => setIsOpen(true)}
          style={styles.openButton}
          onMouseOver={(e) => e.target.style.backgroundColor = '#1d4ed8'}
          onMouseOut={(e) => e.target.style.backgroundColor = '#2563eb'}
        >
          Open Enhanced Job Timeline
        </button>
      </div>
    );
  }

  // Main modal interface
  return (
    <>
      {/* Backdrop */}
      <div 
        style={styles.backdrop}
        onClick={() => setIsOpen(false)} 
      />
      
      {/* Modal */}
      <div style={styles.modal}>
        {/* Header */}
        <div style={styles.header}>
          <h1 style={styles.headerTitle}>
            Enhanced Job Timeline (30 Hours)
          </h1>
          <button
            onClick={() => setIsOpen(false)}
            style={styles.closeButton}
            onMouseOver={(e) => e.target.style.backgroundColor = '#f3f4f6'}
            onMouseOut={(e) => e.target.style.backgroundColor = 'transparent'}
          >
            <X style={{ width: '20px', height: '20px', color: '#6b7280' }} />
          </button>
        </div>

        {/* Main content */}
        <div style={styles.mainContent}>
          <div style={styles.chartContainer}>
            {/* Timeline header */}
            <div style={styles.timelineHeader}>
              <div style={{...styles.timelineHeaderContent, minWidth: `${columnWidth + 30 * 60}px`}}>
                <div 
                  style={{...styles.jobNameColumn, width: `${columnWidth}px`}}
                >
                  <span style={styles.jobNameText}>
                    Job / Batch Hierarchy (Local Time)
                  </span>
                  
                  {/* Resize handle */}
                  <div
                    style={{
                      ...styles.resizeHandle,
                      backgroundColor: isResizing ? '#3b82f6' : 'transparent'
                    }}
                    onMouseDown={handleMouseDown}
                    onMouseOver={(e) => {
                      if (!isResizing) e.target.style.backgroundColor = '#dbeafe';
                    }}
                    onMouseOut={(e) => {
                      if (!isResizing) e.target.style.backgroundColor = 'transparent';
                    }}
                  >
                    <div 
                      style={{
                        ...styles.resizeHandleInner,
                        opacity: isResizing ? 1 : 0.5
                      }}
                      onMouseOver={(e) => e.target.style.opacity = 1}
                      onMouseOut={(e) => {
                        if (!isResizing) e.target.style.opacity = 0.5;
                      }}
                    />
                  </div>
                </div>
                
                <div style={{flexShrink: 0, width: `${30 * 60}px`}}>
                  <div style={styles.timelineGrid}>
                    {timelineRange.map((time, index) => (
                      <div 
                        key={index}
                        style={styles.timeCell}
                      >
                        <div style={styles.timeCellTime}>
                          {time.getHours().toString().padStart(2, '0')}:00
                        </div>
                        {(index === 0 || time.getHours() === 0) && (
                          <div style={styles.timeCellDate}>
                            {time.getDate()}/{time.getMonth() + 1}
                          </div>
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>

            {/* Job rows */}
            <div 
              style={styles.jobRowsContainer}
              onScroll={(e) => {
                const header = e.target.previousElementSibling;
                if (header) {
                  header.scrollLeft = e.target.scrollLeft;
                }
              }}
            >
              <div style={{ minWidth: `${columnWidth + 30 * 60}px`, height: 'fit-content' }}>
                {flatJobs.map((job, index) => {
                  const JobIcon = getJobIcon(job);
                  const statusColor = getStatusColor(job.status);
                  
                  return (
                    <div 
                      key={`${job.id}-${job.level}`}
                      style={{
                        ...styles.jobRow,
                        minWidth: `${columnWidth + 30 * 60}px`
                      }}
                      onMouseOver={(e) => e.currentTarget.style.backgroundColor = '#f9fafb'}
                      onMouseOut={(e) => e.currentTarget.style.backgroundColor = 'transparent'}
                    >
                      {/* Job name column */}
                      <div 
                        style={{
                          ...styles.jobNameCell,
                          width: `${columnWidth}px`
                        }}
                      >
                        <div 
                          style={{
                            ...styles.jobNameContent,
                            paddingLeft: `${job.level * 16}px`
                          }}
                        >
                          {hasChildren(job) && (
                            <button
                              onClick={() => toggleJobCollapse(job.id)}
                              style={styles.expandButton}
                              onMouseOver={(e) => e.target.style.backgroundColor = '#e5e7eb'}
                              onMouseOut={(e) => e.target.style.backgroundColor = 'transparent'}
                            >
                              {collapsedTasks.has(job.id) ? (
                                <ChevronRight style={{ width: '12px', height: '12px' }} />
                              ) : (
                                <ChevronDown style={{ width: '12px', height: '12px' }} />
                              )}
                            </button>
                          )}
                          
                          <JobIcon 
                            style={{
                              ...styles.jobIcon,
                              color: statusColor
                            }}
                          />
                          
                          <div 
                            style={{
                              ...styles.jobName,
                              ...(job.level === 0 ? styles.jobNameLevel0 : 
                                  hasChildren(job) ? styles.jobNameParent : 
                                  styles.jobNameChild)
                            }}
                            title={`${job.name} (Level ${job.level})`}
                            onMouseEnter={(e) => {
                              setHoveredJob({...job, isNameTooltip: true});
                              setTooltipPosition({
                                x: e.clientX,
                                y: e.clientY
                              });
                            }}
                            onMouseLeave={() => {
                              if (hoveredJob?.isNameTooltip) {
                                setHoveredJob(null);
                              }
                            }}
                            onMouseMove={(e) => {
                              if (hoveredJob?.isNameTooltip) {
                                setTooltipPosition({
                                  x: e.clientX,
                                  y: e.clientY
                                });
                              }
                            }}
                          >
                            {job.name}
                          </div>
                        </div>
                        
                        {/* Resize handle for each row */}
                        <div
                          style={{
                            ...styles.resizeHandle,
                            backgroundColor: isResizing ? '#3b82f6' : 'transparent'
                          }}
                          onMouseDown={handleMouseDown}
                          onMouseOver={(e) => {
                            if (!isResizing) e.target.style.backgroundColor = '#dbeafe';
                          }}
                          onMouseOut={(e) => {
                            if (!isResizing) e.target.style.backgroundColor = 'transparent';
                          }}
                        />
                      </div>

                      {/* Timeline column */}
                      <div style={{
                        ...styles.timelineCell,
                        width: `${30 * 60}px`
                      }}>
                        <div style={styles.timelineBar}>
                          <div 
                            style={{
                              ...styles.jobBar,
                              ...getJobBarStyle(job),
                              backgroundColor: statusColor,
                              height: job.level === 0 ? '24px' : hasChildren(job) ? '20px' : '16px',
                              opacity: job.level === 0 ? 1 : hasChildren(job) ? 0.9 : 0.8,
                              border: job.level > 3 ? '1px solid rgba(255,255,255,0.3)' : 'none'
                            }}
                            onMouseEnter={(e) => {
                              if (!hoveredJob?.isNameTooltip) {
                                handleJobBarHover(job, e);
                              }
                            }}
                            onMouseLeave={() => {
                              if (!hoveredJob?.isNameTooltip) {
                                handleJobBarLeave();
                              }
                            }}
                            onMouseMove={(e) => {
                              if (hoveredJob?.id === job.id && !hoveredJob?.isNameTooltip) {
                                setTooltipPosition({
                                  x: e.clientX,
                                  y: e.clientY
                                });
                              }
                            }}
                          >
                            {job.progress > 0 && job.progress < 100 && (
                              <div 
                                style={{
                                  ...styles.jobBarProgress,
                                  width: `${job.progress}%`
                                }}
                              />
                            )}
                            
                            {(job.level === 0 || (hasChildren(job) && job.level <= 1)) && (
                              <div 
                                style={{
                                  ...styles.jobBarText,
                                  fontSize: job.level === 0 ? '12px' : '12px'
                                }}
                              >
                                {job.startdate ? job.name : 'No Schedule'}
                              </div>
                            )}
                          </div>
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
          
          {/* Footer statistics */}
          <div style={styles.footer}>
            <div style={styles.footerStats}>
              <div>
                <strong>{flatJobs.length}</strong> total items
              </div>
              <div>
                <strong>{Math.max(...flatJobs.map(j => j.level)) + 1}</strong> max depth
              </div>
              <div>
                <strong>{flatJobs.filter(j => j.children && j.children.length > 0).length}</strong> containers
              </div>
              <div>
                <strong>{flatJobs.filter(j => !j.children || j.children.length === 0).length}</strong> jobs
              </div>
            </div>
            
            {/* Legend */}
            <div style={styles.legend}>
              <div style={styles.legendItem}>
                <CheckCircle style={{...styles.legendIcon, color: '#10b981'}} />
                <span style={styles.legendText}>Success</span>
              </div>
              <div style={styles.legendItem}>
                <Play style={{...styles.legendIcon, color: '#f59e0b'}} />
                <span style={styles.legendText}>Running</span>
              </div>
              <div style={styles.legendItem}>
                <XCircle style={{...styles.legendIcon, color: '#ef4444'}} />
                <span style={styles.legendText}>Failed</span>
              </div>
              <div style={styles.legendItem}>
                <Pause style={{...styles.legendIcon, color: '#6b7280'}} />
                <span style={styles.legendText}>Waiting</span>
              </div>
              <div style={styles.legendItem}>
                <Folder style={{...styles.legendIcon, color: '#3b82f6'}} />
                <span style={styles.legendText}>Has Children</span>
              </div>
            </div>
          </div>
        </div>

        {/* Tooltip */}
        {hoveredJob && (
          <div 
            style={{
              ...styles.tooltip,
              left: `${tooltipPosition.x + 10}px`,
              top: `${tooltipPosition.y - 10}px`,
              transform: 'translateY(-100%)'
            }}
          >
            {hoveredJob.isNameTooltip ? (
              <div style={{ fontSize: '14px' }}>
                <div style={{ fontWeight: '600', marginBottom: '4px' }}>
                  {hoveredJob.name.replace(/_/g, ' ')}
                </div>
                <div style={{ fontSize: '12px', color: '#d1d5db' }}>
                  Level {hoveredJob.level} • {hasChildren(hoveredJob) ? 'Parent' : 'Job'}
                </div>
              </div>
            ) : (
              <>
                <div style={styles.tooltipTitle}>
                  {hoveredJob.name}
                </div>
                
                <div style={styles.tooltipContent}>
                  <div style={styles.tooltipRow}>
                    <span style={styles.tooltipLabel}>Type:</span>
                    <span style={styles.tooltipValue}>
                      {hasChildren(hoveredJob) ? 'Parent' : 'Job'}
                    </span>
                  </div>
                  
                  <div style={styles.tooltipRow}>
                    <span style={styles.tooltipLabel}>Level:</span>
                    <span style={styles.tooltipValue}>{hoveredJob.level}</span>
                  </div>
                  
                  <div style={styles.tooltipRow}>
                    <span style={styles.tooltipLabel}>Status:</span>
                    <span 
                      style={{
                        ...styles.tooltipValue,
                        color: getStatusColor(hoveredJob.status)
                      }}
                    >
                      {hoveredJob.status}
                    </span>
                  </div>
                  
                  <div style={styles.tooltipRow}>
                    <span style={styles.tooltipLabel}>Start:</span>
                    <span>{formatDateTime(hoveredJob.startdate)}</span>
                  </div>
                  
                  <div style={styles.tooltipRow}>
                    <span style={styles.tooltipLabel}>End:</span>
                    <span>{formatDateTime(hoveredJob.enddate)}</span>
                  </div>
                  
                  <div style={styles.tooltipRow}>
                    <span style={styles.tooltipLabel}>Duration:</span>
                    <span>{formatDuration(hoveredJob.startdate, hoveredJob.enddate)}</span>
                  </div>
                  
                  <div style={styles.tooltipRow}>
                    <span style={styles.tooltipLabel}>Progress:</span>
                    <span style={styles.tooltipValue}>{hoveredJob.progress}%</span>
                  </div>
                  
                  {hoveredJob.children && hoveredJob.children.length > 0 && (
                    <div style={styles.tooltipRow}>
                      <span style={styles.tooltipLabel}>Children:</span>
                      <span style={styles.tooltipValue}>{hoveredJob.children.length}</span>
                    </div>
                  )}
                  
                  {hoveredJob.dependency && hoveredJob.dependency.length > 0 && (
                    <div style={styles.tooltipDependencies}>
                      <span style={styles.tooltipLabel}>Dependencies:</span>
                      <div style={{ marginTop: '4px' }}>
                        {hoveredJob.dependency.map(dep => (
                          <div 
                            key={dep} 
                            style={styles.tooltipDependencyTag}
                          >
                            {dep}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              </>
            )}
            
            {/* Tooltip arrow */}
            <div style={styles.tooltipArrow} />
          </div>
        )}
      </div>
    </>
  );
};

export default JobGanttChart;
