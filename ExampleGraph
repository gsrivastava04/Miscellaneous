// GraphOnly.tsx - Optimized for 10,000+ nodes
import React, { useRef, useEffect, useState, useCallback, useMemo } from 'react';
import * as d3 from 'd3';
import { useLocation } from 'react-router-dom';
import * as js from '../services/jobService.js';
import * as api from '../services/api.js';
import { D3Link, D3Node, RunHistoryEntry } from '../types/models.js';
import { createHierarchy } from '../utils/hierarchy.js';
import DetailTabs from './DetailTabs.js';
import PageHeader from './PageHeader.js';
import NodeDetail from './NodeDetail.js';
import axios from 'axios';
import { QuadTree } from '../utils/quadtree.js'; // Custom quadtree implementation

// Worker for force simulation
const forceSimulationWorker = new Worker(new URL('../workers/forceSimulation.worker.ts', import.meta.url));

// Constants for better performance
const RENDER_BATCH_SIZE = 1000; // Number of nodes to render per frame
const NODE_RADIUS = 5; // Smaller radius for better performance
const VISIBLE_DETAIL_THRESHOLD = 3; // Zoom level at which to show details
const THROTTLE_DELAY = 100; // ms to throttle pan/zoom events

// Utility throttle function
const throttle = (func, delay) => {
  let lastCall = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      func(...args);
    }
  };
};

interface GraphVisualizerProps {
  width?: number;
  height?: number;
}

/**
 * Optimized GraphOnly Component
 * - Uses a hybrid Canvas + SVG approach
 * - Implements spatial indexing via quadtree
 * - Offloads force simulation to Web Worker
 * - Implements level of detail rendering
 * - Uses throttling for expensive operations
 * - Implements efficient event delegation
 */
const GraphOnly: React.FC<GraphVisualizerProps> = React.memo(({
  width = window.innerWidth,
  height = window.innerHeight,
}) => {
  // Component state
  const [appName, setAppName] = useState('COGS');
  const [displayName, setDisplayName] = useState('COGS');
  const [isSimulationRunning, setIsSimulationRunning] = useState<boolean>(true);
  const [data, setData] = useState<any>(null);
  const [nodes, setNodes] = useState<D3Node[]>([]);
  const [links, setLinks] = useState<D3Link[]>([]);
  const [selectedNode, setSelectedNode] = useState<D3Node | null>(null);
  const [highlightedNodes, setHighlightedNodes] = useState<Set<string>>(new Set());
  const [zoomLevel, setZoomLevel] = useState<number>(1);
  const [transform, setTransform] = useState({ x: 0, y: 0, k: 1 });
  const [showOverlay, setShowOverlay] = useState<boolean>(false);
  const [overlayNode, setOverlayNode] = useState<D3Node | null>(null);
  const [user, setUser] = useState('');
  const [password, setPassword] = useState('');
  const [updatedNodeIds, setUpdatedNodeIds] = useState<Set<string>>(new Set());
  const [viewportNodes, setViewportNodes] = useState<D3Node[]>([]);
  const [interactiveNodeIds, setInteractiveNodeIds] = useState<Set<string>>(new Set());

  // Refs for DOM elements and persistent values
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const svgRef = useRef<SVGSVGElement | null>(null);
  const nodesRef = useRef<D3Node[]>([]);
  const linksRef = useRef<D3Link[]>([]);
  const quadtreeRef = useRef<any>(null);
  const animationFrameId = useRef<number | null>(null);
  const isDragging = useRef<boolean>(false);
  const renderStartIndex = useRef<number>(0);
  const previousTransform = useRef({ x: 0, y: 0, k: 1 });
  const needsFullRedraw = useRef<boolean>(true);
  const nodePositionsCache = useRef<Map<string, {x: number, y: number}>>(new Map());
  const location = useLocation();

  // Status symbols mapping - same as original
  const statusSymbols = {
    Success: { symbol: "✓", color: "green" },
    Failure: { symbol: "✗", color: "red" },
    Running: { symbol: "▶", color: "blue" },
    Waiting: { symbol: "⏳", color: "blue" },
    On_Ice: { symbol: "❄", color: "orange" },
    _: { symbol: "□", color: "gray" },
  };

  // For batched rendering
  useEffect(() => {
    if (nodes.length > 0 && !isSimulationRunning) {
      startBatchRendering();
    }
    return () => {
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
      }
    };
  }, [nodes, isSimulationRunning]);

  // Load user credentials
  useEffect(() => {
    if (location.state?.user && location.state?.password) {
      setUser(location.state.user);
      setPassword(location.state.password);
    } else {
      console.error("User or password not provided in navigation state");
    }
  }, [location.state]);

  // Set up API sync
  useEffect(() => {
    const handleSync = async (appName: string) => {
      if (!user || !password) return;
      
      try {
        await axios.post(`/api/service/sync?appId=${appName}`, {
          enabled: true
        }, {
          headers: { user, password }
        });
      } catch (error) {
        console.error("Error syncing:", error);
      }
    };
    
    if (user && password && appName) {
      handleSync(appName);
    }
  }, [appName, user, password]);

  // Fetch job data
  useEffect(() => {
    const fetchJobs = async () => {
      if (!appName || !user || !password) return;
      
      setIsSimulationRunning(true);
      try {
        const jobs = await api.fetchJobs(appName, user, password);
        setData(jobs);
      } catch (error) {
        console.error("Error fetching jobs:", error);
        setIsSimulationRunning(false);
      }
    };
    
    fetchJobs();
  }, [appName, user, password]);

  // Set up SSE connection with throttling
  useEffect(() => {
    if (!appName) return;
    
    let eventSource: EventSource | null = null;
    let updateQueue: any[] = [];
    let updateTimeout: NodeJS.Timeout | null = null;
    
    const processUpdates = () => {
      if (updateQueue.length === 0) return;
      
      const batchedUpdates = [...updateQueue];
      updateQueue = [];
      
      // Update nodes with new data
      const nodeUpdates = new Map<string, any>();
      batchedUpdates.forEach(job => nodeUpdates.set(job.name, job));
      
      // Only update changed nodes
      const updatedIds = new Set<string>();
      nodesRef.current.forEach(node => {
        const update = nodeUpdates.get(node.name);
        if (update && node.status !== update.status) {
          node.status = update.status;
          node.icontext = statusSymbols[update.status]?.symbol || statusSymbols._.symbol;
          node.color = statusSymbols[update.status]?.color || statusSymbols._.color;
          node.progress = update.progress;
          updatedIds.add(node.id);
        }
      });
      
      // Trigger partial redraw for updated nodes
      if (updatedIds.size > 0) {
        setUpdatedNodeIds(updatedIds);
        needsFullRedraw.current = true;
        renderCanvas();
      }
    };
    
    const startSSE = () => {
      eventSource = new EventSource(`/api/service/sse?appId=${appName}`);
      eventSource.onmessage = (event) => {
        try {
          const updates = JSON.parse(event.data);
          if (Array.isArray(updates) && updates.length > 0) {
            updateQueue.push(...updates);
            
            // Throttle updates to prevent excessive rendering
            if (!updateTimeout) {
              updateTimeout = setTimeout(() => {
                processUpdates();
                updateTimeout = null;
              }, 500); // Process updates at most every 500ms
            }
          }
        } catch (error) {
          console.error("Error processing SSE update:", error);
        }
      };
      eventSource.onerror = () => {
        if (eventSource) {
          eventSource.close();
          // Attempt to reconnect after a delay
          setTimeout(startSSE, 5000);
        }
      };
    };
    
    const stopSSE = () => {
      if (eventSource) {
        eventSource.close();
        eventSource = null;
      }
      if (updateTimeout) {
        clearTimeout(updateTimeout);
        updateTimeout = null;
      }
    };
    
    // Handle tab visibility changes
    const handleVisibilityChange = () => {
      if (document.visibilityState === "visible") {
        startSSE();
      } else {
        stopSSE();
      }
    };
    
    document.addEventListener("visibilitychange", handleVisibilityChange);
    startSSE();
    
    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      stopSSE();
    };
  }, [appName]);

  // Process data and setup force simulation in worker
  useEffect(() => {
    if (!data) return;
    
    try {
      const { idNameMap, nodes: newNodes, links: newLinks, componentTypes } = createHierarchy(data, true);
      
      // Cache initial positions
      newNodes.forEach(node => {
        if (!nodePositionsCache.current.has(node.id)) {
          nodePositionsCache.current.set(node.id, { 
            x: Math.random() * width, 
            y: Math.random() * height 
          });
        }
        // Apply cached position
        const cachedPos = nodePositionsCache.current.get(node.id);
        if (cachedPos) {
          node.x = cachedPos.x;
          node.y = cachedPos.y;
        }
      });
      
      // Update refs and state
      nodesRef.current = newNodes;
      linksRef.current = newLinks;
      setNodes(newNodes);
      setLinks(newLinks);
      
      // Build quadtree for spatial indexing
      rebuildQuadtree(newNodes);
      
      // Start force simulation in worker
      startForceSimulation(newNodes, newLinks);
      
    } catch (error) {
      console.error("Error processing graph data:", error);
      setIsSimulationRunning(false);
    }
  }, [data, width, height]);

  // Initialize Canvas and SVG 
  useEffect(() => {
    const canvas = canvasRef.current;
    const svg = svgRef.current;
    
    if (!canvas || !svg || nodes.length === 0) return;
    
    // Set up canvas
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    // Adjust for device pixel ratio for sharp rendering
    const pixelRatio = window.devicePixelRatio || 1;
    canvas.width = width * pixelRatio;
    canvas.height = height * pixelRatio;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    ctx.scale(pixelRatio, pixelRatio);
    
    // Set up zoom behavior
    const zoom = d3.zoom()
      .scaleExtent([0.1, 10])
      .on('zoom', throttle((event) => {
        const newTransform = event.transform;
        setTransform(newTransform);
        
        // Only do full recalculation if zoom level changed significantly
        if (Math.abs(previousTransform.current.k - newTransform.k) > 0.1) {
          updateViewportNodes(newTransform);
          setZoomLevel(newTransform.k);
        } else {
          // For small changes in position, just update the transform
          needsFullRedraw.current = true;
        }
        
        previousTransform.current = newTransform;
        renderCanvas();
      }, THROTTLE_DELAY));
    
    // Apply zoom to SVG
    d3.select(svg).call(zoom);
    
    // Initial zoom to fit
    zoomToFit();
    
    // Initial render
    needsFullRedraw.current = true;
    renderCanvas();
    
    return () => {
      // Clean up zoom
      d3.select(svg).on('.zoom', null);
    };
  }, [nodes, width, height]);

  // Force simulation in Web Worker
  const startForceSimulation = (nodes: D3Node[], links: D3Link[]) => {
    setIsSimulationRunning(true);
    
    // Listen for messages from the worker
    forceSimulationWorker.onmessage = (event) => {
      const { type, data } = event.data;
      
      if (type === 'tick') {
        // Update positions from simulation
        const updatedPositions = data.positions;
        let hasChanged = false;
        
        // Apply new positions to nodes
        nodes.forEach((node, i) => {
          if (i < updatedPositions.length) {
            const newPos = updatedPositions[i];
            if (Math.abs(node.x - newPos.x) > 0.1 || Math.abs(node.y - newPos.y) > 0.1) {
              node.x = newPos.x;
              node.y = newPos.y;
              // Update cache
              nodePositionsCache.current.set(node.id, { x: newPos.x, y: newPos.y });
              hasChanged = true;
            }
          }
        });
        
        if (hasChanged) {
          // Rebuild quadtree with new positions
          rebuildQuadtree(nodes);
          // Redraw canvas
          needsFullRedraw.current = true;
          renderCanvas();
        }
      } 
      else if (type === 'end') {
        // Simulation completed
        console.log("Force simulation completed");
        setIsSimulationRunning(false);
        needsFullRedraw.current = true;
        renderCanvas();
      }
    };
    
    // Send nodes and links to worker
    const nodeData = nodes.map(n => ({ 
      id: n.id, 
      x: n.x, 
      y: n.y, 
      // Only send necessary data to worker
      fixed: !!n.fx 
    }));
    
    const linkData = links.map(l => ({
      source: typeof l.source === 'object' ? l.source.id : l.source,
      target: typeof l.target === 'object' ? l.target.id : l.target,
      value: l.value || 1
    }));
    
    forceSimulationWorker.postMessage({
      type: 'start',
      data: {
        nodes: nodeData,
        links: linkData,
        width,
        height
      }
    });
  };

  // Rebuild quadtree for spatial queries
  const rebuildQuadtree = (nodes: D3Node[]) => {
    quadtreeRef.current = d3.quadtree()
      .x(d => d.x)
      .y(d => d.y)
      .addAll(nodes);
  };

  // Update viewport nodes based on current view
  const updateViewportNodes = (newTransform: d3.ZoomTransform) => {
    if (!nodes.length || !canvasRef.current) return;
    
    // Calculate visible area in graph coordinates
    const visibleArea = {
      x0: -newTransform.x / newTransform.k,
      y0: -newTransform.y / newTransform.k,
      x1: (width - newTransform.x) / newTransform.k,
      y1: (height - newTransform.y) / newTransform.k
    };
    
    // Expand area for smoother panning
    const margin = 100 / newTransform.k;
    visibleArea.x0 -= margin;
    visibleArea.y0 -= margin;
    visibleArea.x1 += margin;
    visibleArea.y1 += margin;
    
    // Use quadtree to efficiently find nodes in visible area
    const visible: D3Node[] = [];
    quadtreeRef.current.visit((node, x0, y0, x1, y1) => {
      if (!node.length) {
        // Leaf node
        const d = node.data;
        if (d.x >= visibleArea.x0 && d.x <= visibleArea.x1 && 
            d.y >= visibleArea.y0 && d.y <= visibleArea.y1) {
          visible.push(d);
        }
      }
      // Return true to skip if this quad is completely outside visible area
      return x1 < visibleArea.x0 || x0 > visibleArea.x1 || 
             y1 < visibleArea.y0 || y0 > visibleArea.y1;
    });
    
    // For high zoom levels, we'll render more details
    const shouldRenderInteractive = newTransform.k >= VISIBLE_DETAIL_THRESHOLD;
    
    // Identify nodes that should be rendered as interactive SVG elements
    const interactiveIds = new Set<string>();
    if (shouldRenderInteractive) {
      // Limit interactive nodes to a reasonable number
      const maxInteractiveNodes = 50;
      visible.slice(0, maxInteractiveNodes).forEach(node => {
        interactiveIds.add(node.id);
      });
    }
    
    // If selected node exists, make sure it's interactive
    if (selectedNode) {
      interactiveIds.add(selectedNode.id);
      
      // Also make connected nodes interactive
      linksRef.current.forEach(link => {
        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
        
        if (sourceId === selectedNode.id) {
          interactiveIds.add(targetId);
        } else if (targetId === selectedNode.id) {
          interactiveIds.add(sourceId);
        }
      });
    }
    
    setViewportNodes(visible);
    setInteractiveNodeIds(interactiveIds);
  };

  // Batch rendering for better performance
  const startBatchRendering = () => {
    if (!nodes.length) return;
    
    renderStartIndex.current = 0;
    
    const renderBatch = () => {
      if (!canvasRef.current) return;
      
      // Render everything if a full redraw is needed
      if (needsFullRedraw.current) {
        renderCanvas();
        needsFullRedraw.current = false;
        renderStartIndex.current = 0;
        animationFrameId.current = requestAnimationFrame(renderBatch);
        return;
      }
      
      // Otherwise, render in batches
      const ctx = canvasRef.current.getContext('2d');
      if (!ctx) return;
      
      // Calculate batch end index
      const endIndex = Math.min(renderStartIndex.current + RENDER_BATCH_SIZE, nodes.length);
      
      // Render this batch
      const { k, x, y } = transform;
      
      for (let i = renderStartIndex.current; i < endIndex; i++) {
        const node = nodes[i];
        drawNode(ctx, node, x, y, k);
      }
      
      // Move to next batch
      renderStartIndex.current = endIndex;
      
      // Continue if more nodes to render
      if (renderStartIndex.current < nodes.length) {
        animationFrameId.current = requestAnimationFrame(renderBatch);
      }
    };
    
    // Start the batch rendering process
    animationFrameId.current = requestAnimationFrame(renderBatch);
  };

  // Main canvas rendering function
  const renderCanvas = () => {
    const canvas = canvasRef.current;
    const svg = svgRef.current;
    if (!canvas || !svg || !nodes.length) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);
    
    // Apply current transform
    ctx.save();
    ctx.translate(transform.x, transform.y);
    ctx.scale(transform.k, transform.k);
    
    // Decide what to draw based on zoom level
    const shouldDrawLinks = transform.k > 0.3; // Don't draw links when zoomed out too far
    const shouldDrawLabels = transform.k > 1.5; // Only draw labels when zoomed in
    
    // Draw links if needed
    if (shouldDrawLinks) {
      drawLinks(ctx);
    }
    
    // Draw nodes - only those in viewport for performance
    const visibleNodes = viewportNodes.length > 0 ? viewportNodes : nodes;
    
    // Sort nodes so that highlighted ones are drawn last (on top)
    const nodesToDraw = [...visibleNodes].sort((a, b) => {
      const aHighlighted = highlightedNodes.has(a.id) || a.id === selectedNode?.id;
      const bHighlighted = highlightedNodes.has(b.id) || b.id === selectedNode?.id;
      return aHighlighted === bHighlighted ? 0 : aHighlighted ? 1 : -1;
    });
    
    // Draw all visible nodes
    nodesToDraw.forEach(node => {
      // Skip nodes that will be rendered in SVG
      if (interactiveNodeIds.has(node.id)) return;
      
      drawNode(ctx, node, 0, 0, 1, shouldDrawLabels);
    });
    
    ctx.restore();
    
    // Update SVG for interactive elements
    updateInteractiveSvgElements();
  };

  // Draw a single node on canvas
  const drawNode = (
    ctx: CanvasRenderingContext2D, 
    node: D3Node, 
    offsetX: number, 
    offsetY: number, 
    scale: number, 
    drawLabel: boolean = false
  ) => {
    if (!node.x || !node.y) return;
    
    const x = node.x;
    const y = node.y;
    const isHighlighted = highlightedNodes.has(node.id) || node.id === selectedNode?.id;
    const isUpdated = updatedNodeIds.has(node.id);
    const radius = isHighlighted ? NODE_RADIUS * 1.5 : NODE_RADIUS;
    
    // Draw node circle
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    
    // Style based on state
    if (isHighlighted) {
      ctx.fillStyle = '#ffcc00'; // Highlight color
      ctx.strokeStyle = '#ff6600';
      ctx.lineWidth = 2 / scale;
    } else if (isUpdated) {
      ctx.fillStyle = node.color || '#999';
      ctx.strokeStyle = '#ff0000';
      ctx.lineWidth = 1.5 / scale;
    } else {
      ctx.fillStyle = node.color || '#999';
      ctx.strokeStyle = 'transparent';
      ctx.lineWidth = 0;
    }
    
    ctx.fill();
    if (ctx.lineWidth > 0) {
      ctx.stroke();
    }
    
    // Draw label if zoomed in enough
    if (drawLabel && node.name) {
      ctx.font = `${10 / scale}px Arial`;
      ctx.fillStyle = isHighlighted ? '#000' : '#666';
      ctx.textAlign = 'center';
      ctx.fillText(node.name, x, y - radius - 5 / scale);
      
      // Draw status if available
      if (node.icontext) {
        ctx.fillText(node.icontext, x, y + radius + 12 / scale);
      }
    }
  };

  // Draw links between nodes
  const drawLinks = (ctx: CanvasRenderingContext2D) => {
    const validLinks = linksRef.current.filter(link => {
      // Ensure source and target are objects with x,y coordinates
      const source = typeof link.source === 'object' ? link.source : null;
      const target = typeof link.target === 'object' ? link.target : null;
      return source && target && source.x !== undefined && target.x !== undefined;
    });
    
    // Batch links by whether they're highlighted
    const regularLinks = [];
    const highlightedLinks = [];
    
    validLinks.forEach(link => {
      const source = link.source as D3Node;
      const target = link.target as D3Node;
      
      const isHighlighted = 
        (selectedNode && (source.id === selectedNode.id || target.id === selectedNode.id)) ||
        (highlightedNodes.has(source.id) && highlightedNodes.has(target.id));
        
      if (isHighlighted) {
        highlightedLinks.push(link);
      } else {
        regularLinks.push(link);
      }
    });
    
    // Draw regular links first
    ctx.lineWidth = 0.5;
    ctx.strokeStyle = '#ccc';
    ctx.beginPath();
    
    regularLinks.forEach(link => {
      const source = link.source as D3Node;
      const target = link.target as D3Node;
      
      ctx.moveTo(source.x, source.y);
      ctx.lineTo(target.x, target.y);
    });
    
    ctx.stroke();
    
    // Then draw highlighted links on top
    if (highlightedLinks.length > 0) {
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = '#ff6600';
      ctx.beginPath();
      
      highlightedLinks.forEach(link => {
        const source = link.source as D3Node;
        const target = link.target as D3Node;
        
        ctx.moveTo(source.x, source.y);
        ctx.lineTo(target.x, target.y);
      });
      
      ctx.stroke();
    }
  };

  // Update SVG interactive elements
  const updateInteractiveSvgElements = () => {
    const svg = d3.select(svgRef.current);
    
    // Apply zoom transform to the g element
    const g = svg.select('g.interactive-layer');
    g.attr('transform', `translate(${transform.x},${transform.y}) scale(${transform.k})`);
    
    // Get nodes that should be rendered as SVG
    const interactiveNodes = nodes.filter(node => 
      interactiveNodeIds.has(node.id) && node.x !== undefined && node.y !== undefined
    );
    
    // Update SVG nodes
    const nodeElements = g.selectAll('g.interactive-node')
      .data(interactiveNodes, (d: any) => d.id);
    
    // Remove nodes no longer in the interactive set
    nodeElements.exit().remove();
    
    // Add new interactive nodes
    const enterNodes = nodeElements.enter()
      .append('g')
      .attr('class', 'interactive-node')
      .style('cursor', 'pointer');
    
    // Add circle for each node
    enterNodes.append('circle')
      .attr('r', NODE_RADIUS * 1.2)
      .attr('fill', d => d.color || '#999');
    
    // Add text label
    enterNodes.append('text')
      .attr('dy', -NODE_RADIUS * 2)
      .attr('text-anchor', 'middle')
      .attr('font-size', 10)
      .text(d => d.name);
    
    // Add status indicator
    enterNodes.append('text')
      .attr('dy', NODE_RADIUS * 2.5)
      .attr('text-anchor', 'middle')
      .attr('font-size', 10)
      .text(d => d.icontext || '');
    
    // Update positions of all nodes
    g.selectAll('g.interactive-node')
      .attr('transform', d => `translate(${d.x},${d.y})`);
    
    // Update styles based on selection state
    g.selectAll('g.interactive-node circle')
      .attr('fill', d => d.color || '#999')
      .attr('stroke', d => (d.id === selectedNode?.id) ? '#ff6600' : 'none')
      .attr('stroke-width', d => (d.id === selectedNode?.id) ? 2 : 0);
    
    // Add click handlers
    g.selectAll('g.interactive-node')
      .on('click', (event, d) => handleNodeClick(d))
      .on('contextmenu', (event, d) => {
        event.preventDefault();
        handleNodeRightClick(d);
      })
      .on('mouseenter', (event, d) => handleNodeMouseEnter(d))
      .on('mouseleave', (event, d) => handleNodeMouseLeave());
  };

  // Event handlers for nodes
  const handleNodeClick = (node: D3Node) => {
    setSelectedNode(node);
    highlightConnectedNodes(node);
    needsFullRedraw.current = true;
    renderCanvas();
  };

  const handleNodeRightClick = (node: D3Node) => {
    setOverlayNode(node);
    setShowOverlay(true);
  };

  const handleNodeMouseEnter = (node: D3Node) => {
    if (!isDragging.current) {
      highlightConnectedNodes(node);
      needsFullRedraw.current = true;
      renderCanvas();
    }
  };

  const handleNodeMouseLeave = () => {
    if (!selectedNode && !isDragging.current) {
      setHighlightedNodes(new Set());
      needsFullRedraw.current = true;
      renderCanvas();
    }
  };

  // Helper to find and highlight connected nodes
  const highlightConnectedNodes = (node: D3Node) => {
    const connectedIds = new Set<string>([node.id]);
    
    // Find connected nodes
    linksRef.current.forEach(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      
      if (sourceId === node.id) {
        connectedIds.add(targetId);
      } else if (targetId === node.id) {
        connectedIds.add(sourceId);
      }
    });
    
    setHighlightedNodes(connectedIds);
  };

  // Handle canvas click for node detection
  const handleCanvasClick = (event: React.MouseEvent) => {
    if (isDragging.current) return;
    
    // Get mouse position in canvas coordinates
    const rect = canvasRef.current?.getBoundingClientRect();
    if (!rect) return;
    
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;
    
    // Convert to graph coordinates using current transform
    const graphX = (mouseX - transform.x) / transform.k;
    const graphY = (mouseY - transform.y) / transform.k;
    
    // Use quadtree to find the closest node efficiently
    const searchRadius = 20 / transform.k; // Adjust search radius based on zoom
    const closestNode = findClosestNode(graphX, graphY, searchRadius);
    
    if (closestNode) {
      handleNodeClick(closestNode);
    } else {
      // Clear selection if clicking empty space
      setSelectedNode(null);
      setHighlightedNodes(new Set());
      needsFullRedraw.current = true;
      renderCanvas();
    }
  };

  // Find closest node using quadtree
  const findClosestNode = (x: number, y: number, radius: number): D3Node | null => {
    if (!quadtreeRef.current) return null;
    
    let closestNode: D3Node | null = null;
    let closestDistance = radius;
    
    // Use quadtree to efficiently search for nodes near the point
    quadtreeRef.current.visit((node, x0, y0, x1, y1) => {
      if (!node.length) {
        // Leaf node
        const d = node.data;
        const dx = d.x - x;
        const dy = d.y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < closestDistance) {
          closestDistance = distance;
          closestNode = d;
        }
      }
      
      // Stop traversing if this quad is too far from search point
      return x0 > x + radius || x1 < x - radius || y0 > y + radius || y1 < y - radius;
    });
    
    return closestNode;
  };

  // Zoom to fit all nodes
  const zoomToFit = () => {
    if (!nodes.length || !svgRef.current) return;
    
    // Find bounds of all nodes
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    nodes.forEach(node => {
      if (node.x === undefined || node.y === undefined) return;
      
      minX = Math.min(minX, node.x);
      minY = Math.min(minY, node.y);
      maxX = Math.max(maxX, node.x);
      maxY = Math.max(maxY, node.y);
    });
    
    if (minX === Infinity) return; // No valid nodes
    
    // Add padding
    const padding = 50;
    minX -= padding;
    minY -= padding;
    maxX += padding;
    maxY += padding;
    
    // Calculate center point and scale
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    const scale = Math.min(
      0.8 * width / (maxX - minX),
      0.8 * height / (maxY - minY)
    );
    
    // Apply transform
    const svg = d3.select(svgRef.current);
    const zoom = d3.zoom().on('zoom', null); // Create temporary zoom for transition
    
    svg.transition()
      .duration(750)
      .call(
        zoom.transform as any,
        d3.zoomIdentity
          .translate(width / 2, height / 2)
          .scale(scale)
          .translate(-centerX, -centerY)
      )
      .on('end', () => {
        // Update transform state after transition
        setTransform({
          x: width / 2 - centerX * scale,
          y: height / 2 - centerY * scale,
          k: scale
        });
        previousTransform.current = {
          x: width / 2 - centerX * scale,
          y: height / 2 - centerY * scale,
          k: scale
        };
        
        // Update viewport nodes with new transform
        updateViewportNodes({
          x: width / 2 - centerX * scale,
          y: height / 2 - centerY * scale,
          k: scale
        } as d3.ZoomTransform);
        
        needsFullRedraw.current = true;
        renderCanvas();
      });
  };

  // Render the component
  return (
    <div className="graph-container" style={{ width: '100%', height: '100%', position: 'relative' }}>
      <PageHeader 
        displayName={displayName}
        onZoomToFit={zoomToFit}
      />
      
      {/* Breadcrumb navigation */}
      <div className="breadcrumb" style={{ padding: '5px 10px', borderBottom: '1px solid #eee' }}>
        <ul className="breadcrumb" id="breadcrumb" style={{ listStyle: 'none', padding: 0, margin: 0, display: 'flex' }}>
          <li className="breadcrumb-item" style={{ marginRight: '5px' }}>
            <a href="#" onClick={(e) => { e.preventDefault(); zoomToFit(); }}>Home</a>
          </li>
          {selectedNode && (
            <>
              <li style={{ margin: '0 5px' }}>/</li>
              <li className="breadcrumb-item">{selectedNode.name}</li>
            </>
          )}
        </ul>
      </div>
      
      {/* Controls panel */}
      <div className="controls" style={{ position: 'absolute', top: '50px', left: '10px', zIndex: 5 }}>
        <div style={{ display: 'flex', flexDirection: 'column', background: 'white', padding: '5px', borderRadius: '4px', boxShadow: '0 1px 3px rgba(0,0,0,0.2)' }}>
          <button 
            onClick={zoomToFit}
            style={{ margin: '3px', padding: '5px', cursor: 'pointer' }}
            title="Fit all nodes"
          >
            Fit
          </button>
          <button 
            onClick={() => {
              setTransform({...transform, k: transform.k * 1.2});
              needsFullRedraw.current = true;
              renderCanvas();
            }}
            style={{ margin: '3px', padding: '5px', cursor: 'pointer' }}
            title="Zoom in"
          >
            +
          </button>
          <button 
            onClick={() => {
              setTransform({...transform, k: transform.k / 1.2});
              needsFullRedraw.current = true;
              renderCanvas();
            }}
            style={{ margin: '3px', padding: '5px', cursor: 'pointer' }}
            title="Zoom out"
          >
            -
          </button>
          <button 
            onClick={() => {
              setHighlightedNodes(new Set());
              setSelectedNode(null);
              needsFullRedraw.current = true;
              renderCanvas();
            }}
            style={{ margin: '3px', padding: '5px', cursor: 'pointer' }}
            title="Clear selection"
          >
            Clear
          </button>
        </div>
      </div>
      
      {/* Stats display */}
      <div style={{ position: 'absolute', bottom: '10px', left: '10px', background: 'rgba(255,255,255,0.8)', padding: '5px', borderRadius: '4px', fontSize: '12px' }}>
        <div>Nodes: {nodes.length.toLocaleString()}</div>
        <div>Links: {links.length.toLocaleString()}</div>
        <div>Zoom: {transform.k.toFixed(1)}x</div>
        <div>Visible: {viewportNodes.length.toLocaleString()}</div>
      </div>
      
      {/* Loading overlay */}
      {isSimulationRunning && (
        <div
          style={{
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            backgroundColor: "rgba(0, 0, 0, 0.5)",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            zIndex: 10,
          }}
        >
          <div style={{ color: "white", fontSize: "18px" }}>
            Loading Graph ({nodes.length.toLocaleString()} nodes)...
          </div>
        </div>
      )}
      
      {/* Main visualization container */}
      <div 
        className="visualization-container"
        style={{ position: 'relative', width: '100%', height: 'calc(100% - 40px)' }}
      >
        {/* Canvas for efficient rendering of most nodes/links */}
        <canvas
          ref={canvasRef}
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            width: `${width}px`,
            height: `${height}px`,
          }}
          onClick={handleCanvasClick}
        />
        
        {/* SVG overlay for interactive elements */}
        <svg
          ref={svgRef}
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            width: `${width}px`,
            height: `${height}px`,
            pointerEvents: 'none', // Let events pass through to canvas except for nodes
          }}
        >
          <defs>
            {/* Define markers for arrows */}
            <marker
              id="arrow"
              viewBox="0 0 10 10"
              refX="5"
              refY="5"
              markerWidth="6"
              markerHeight="6"
              orient="auto-start-reverse"
            >
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#999" />
            </marker>
            <marker
              id="arrow-highlighted"
              viewBox="0 0 10 10"
              refX="5"
              refY="5"
              markerWidth="6"
              markerHeight="6"
              orient="auto-start-reverse"
            >
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#ff6600" />
            </marker>
          </defs>
          <g className="interactive-layer">
            {/* Interactive SVG nodes will be rendered here */}
          </g>
        </svg>
      </div>
      
      {/* Node detail overlay */}
      {showOverlay && overlayNode && (
        <div
          style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'white',
            boxShadow: '0 4px 8px rgba(0,0,0,0.2)',
            zIndex: 20,
            borderRadius: '4px',
            width: `${width / 3}px`,
            maxHeight: `${height / 2}px`,
            overflow: 'auto',
          }}
        >
          <div style={{ display: 'flex', justifyContent: 'space-between', padding: '10px', borderBottom: '1px solid #eee' }}>
            <h3 style={{ margin: 0 }}>{overlayNode.name}</h3>
            <button
              onClick={() => {
                setShowOverlay(false);
                setOverlayNode(null);
              }}
              style={{ background: 'none', border: 'none', cursor: 'pointer', fontSize: '16px' }}
            >
              ×
            </button>
          </div>
          <div style={{ padding: '10px' }}>
            <NodeDetail
              node={overlayNode}
              appName={appName}
              width={width / 3 - 20}
              height={height / 2 - 60}
              onClose={() => {
                setShowOverlay(false);
                setOverlayNode(null);
              }}
            />
          </div>
        </div>
      )}
      
      {/* Detail panel for selected node */}
      {selectedNode && (
        <div 
          className="detail-panel"
          style={{
            position: 'absolute',
            right: 0,
            top: 60,
            width: '300px',
            height: `${height - 60}px`,
            background: 'white',
            boxShadow: '-2px 0 5px rgba(0,0,0,0.1)',
            zIndex: 5,
            overflow: 'hidden',
            display: 'flex',
            flexDirection: 'column',
          }}
        >
          <div style={{ padding: '10px', borderBottom: '1px solid #eee' }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <h3 style={{ margin: 0 }}>{selectedNode.name}</h3>
              <button
                onClick={() => {
                  setSelectedNode(null);
                  setHighlightedNodes(new Set());
                  needsFullRedraw.current = true;
                  renderCanvas();
                }}
                style={{ background: 'none', border: 'none', cursor: 'pointer', fontSize: '16px' }}
              >
                ×
              </button>
            </div>
            <div style={{ 
              padding: '5px',
              marginTop: '5px',
              background: selectedNode.color || '#eee',
              color: selectedNode.color === 'green' ? 'white' : 'black',
              borderRadius: '4px',
              display: 'inline-block'
            }}>
              Status: {selectedNode.status} {selectedNode.icontext}
            </div>
            {selectedNode.progress !== undefined && (
              <div style={{ marginTop: '10px' }}>
                <div>Progress: {Math.round(selectedNode.progress * 100)}%</div>
                <div style={{ 
                  height: '8px', 
                  width: '100%', 
                  background: '#eee', 
                  borderRadius: '4px',
                  marginTop: '5px'
                }}>
                  <div style={{ 
                    height: '100%', 
                    width: `${Math.round(selectedNode.progress * 100)}%`,
                    background: selectedNode.color || '#999',
                    borderRadius: '4px'
                  }} />
                </div>
              </div>
            )}
          </div>
          <div style={{ flex: 1, overflow: 'auto' }}>
            <DetailTabs
              width={300}
              height={height - 150}
              selectedNode={selectedNode}
              nodes={nodes}
              links={links}
            />
          </div>
        </div>
      )}
    </div>
  );
});

// Web worker code for force simulation
// This would be in a separate file: forceSimulation.worker.ts
/*
self.onmessage = (event) => {
  const { type, data } = event.data;
  
  if (type === 'start') {
    const { nodes, links, width, height } = data;
    
    // Import D3 force modules
    importScripts('https://d3js.org/d3.v7.min.js');
    
    // Create force simulation
    const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id).distance(50))
      .force("charge", d3.forceManyBody().strength(-100))
      .force("center", d3.forceCenter(width / 2, height / 2))
      .force("collide", d3.forceCollide(10))
      .alphaDecay(0.01) // Slower decay for more stable positioning
      .alpha(0.3)
      .alphaMin(0.001);
    
    // Send updates periodically rather than every tick
    let tickCounter = 0;
    
    simulation.on('tick', () => {
      tickCounter++;
      
      // Only send updates every few ticks to reduce message overhead
      if (tickCounter % 5 === 0) {
        const positions = nodes.map(node => ({
          id: node.id,
          x: node.x,
          y: node.y
        }));
        
        self.postMessage({
          type: 'tick',
          data: { positions }
        });
      }
    });
    
    simulation.on('end', () => {
      // Send final positions
      const positions = nodes.map(node => ({
        id: node.id,
        x: node.x,
        y: node.y
      }));
      
      self.postMessage({
        type: 'end',
        data: { positions }
      });
    });
  }
};
*/

export default GraphOnly;
